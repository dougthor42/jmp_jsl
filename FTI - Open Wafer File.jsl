//!

Names Default to Here(1);

// Prompt the user for the file to load.
a = New Window(
	"Select an FTI file to load:",
	<< Modal,
		Text Box("File to Load:"),
		Line Up Box(
			NCol(2),
			editBox = Text Edit Box(
				"",
				Set Width(650)
			),
			Button Box(
				"Browse",
				Set Script(
					editBox << Set Text(
						Pick File(
							"Something", 				// prompt
							"Z:\Power\AP Data\FTI\",	// Initial dir
							{"CSV Files|csv"},			// filter list
							1,							// First Filter
							0							// save flag
						)
					)
				)
			),
		),
	Button Box("OK"),
	Button Box("Cancel")
);
// Stop the script if the user cancels
If( a["Button"] == -1,
	Stop()
);

file_path = editBox << Get Text;
Show(file_path);

// Verify that we're using a .csv file
If( Right(file_path, 4) != ".csv",
	Stop()
);

// Load the text file so that we can find the data_start line and the
// header line.
raw_data = Load Text File(file_path);
//Show(raw_data);


// Search for ",,,,,,,,,Test"  13 characters
// Search for "Device,Site,X"

// Since I can't seem to find a function that converts a string
// to a list (like str.split() in Python...), I'll hack one together.
// Technically it won't split the string into a list, but it will count
// the number of lines and then it will return values for the header line
// and the data_start line.
// This function will iterate through the string, counting CRLFs.
// If the CRLF is followed by ",,,,,,,,,Test", then that one is
// set to the col_names_start variable.
// If the CRLF is followed by "Device,Site,X,Y,", then that one is
// set to the data_start_line variable and we break the loop.
col_names_start = -1;
data_start = -1;
line_num = 1;
col_num = 1;
n = 1;
prev_str = "";
line_string = "";
start_of_line_bool = 1;
While(
	// Run indefinitely
	1,
	
	// Get the current character in the string
	substring = Substr(raw_data, n, 1);

	// Gotta make sure we increment n, or else we'll look infinitely.
	n ++;
	col_num ++;

	// if the previous character and this character make a CRLF, then
	// we increment our line counter, state that we're at the start
	// of a line, and reset our column number
	If(
		prev_str || substring == "\!N",		// "\!N" matches the host OS's line break character
		//Print(line_string);
		line_num ++;
		start_of_line_bool = 1;
		col_num = 1;
		line_string = "";
		Continue();							// Don't bother with the rest of the loop
	);

	// Set the previous string and append to the full line string
	prev_str = substring;
	line_string ||= substring;

	// Then check if our start of line string matches one of our two searches
	If(
		Starts With(line_string, ",,,,,,,,,Test,") | Starts With(line_string, ",,,,,,Test,"),
		col_names_start = line_num;
		Continue();
	);
	If(
		Starts With (line_string, "Device,Site,"),
		data_start = line_num + 1;
		Break();
	);

	// Make sure we don't run forever. Used only in development.
	/*
	If(
		n >= 8000,
		Break();
	);
	*/
);

Show(line_num);
Show(col_names_start);
Show(data_start);

//Stop();

// Open the file into JMP
dt1 = Open(
	file_path,
	Import Settings(
		End Of Line( CRLF, CR, LF ),
		End Of Field( Comma, CSV( 0 ) ),
		Strip Quotes( 1 ),
		Use Apostrophe as Quotation Mark( 0 ),
		Scan Whole File( 1 ),
		Treat empty columns as numeric( 0 ),
		CompressNumericColumns( 0 ),
		CompressCharacterColumns( 0 ),
		CompressAllowListCheck( 0 ),
		Labels( 1 ),
		Column Names Start( col_names_start ),
		Data Starts( data_start ),
		Lines To Read( "All" ),
		Year Rule( "20xx" )
	)
);

// Rename the columns that have headers not on line 25
Column("Column 1") << Set Name("Device");
Column("Column 2") << Set Name("Site");
Column("Column 3") << Set Name("X");
Column("Column 4") << Set Name("Y");
Column("Column 5") << Set Name("Soft Bin");
Column("Column 6") << Set Name("Hard Bin");
Column("Column 7") << Set Name("Wafer");
Column("Column 8") << Set Name("Failed");
Column("Column 9") << Set Name("Alarmed");
//Column("Column 10") << Set Name("Message");


// Figure out what mask we're using and then set the equation for Radius.
// Get the Mask Name from the filename.
mask = Left(dt1 << Get Name(), 5);		// TODO: change to account for arbitrary mask name lengths
Show(mask);

// Lookup the Die Size (X, Y). Assume 07G11 if not found.
dieSize = Match(
	mask,
	"MDH27", {4.34, 6.44},
	"07G11", {2.43, 3.3},
	"07G13", {4.37, 6.47},
	"07G14", {2.33, 2.07},
	{2.43, 3.3}
);

// Look up the CenterXY coord. Assume 07G11 if not found.
centerXY = Match(
	mask,
	"MDH27", {18.5, 12.5},
	"07G11", {29, 21},
	"07G13", {16.5, 9.5},
	"07G14", {30.5, 33.5},
	{29, 21}
);

Show(dieSize);
Show(centerXY);

// Add a Radius (mm) column.
radiusCol = dt1 << New Column("Radius (mm)");
radiusCol << Set Formula(
	Root(
		(dieSize[1] * (:Name("X") - centerXY[1])) ^ 2
		+ 
		(dieSize[2] * (:Name("Y") - centerXY[2])) ^ 2,
		Empty()
	)
);
radiusCol << EvalFormula;

// Add a Radius^2 column.
radius2Col = New Column("Radius^2");
radius2Col << Set Formula(
	:Name( "Radius (mm)" )^2 
);
radius2Col << EvalFormula;

// Some columns have value of "infinity", so we need to remove those and set
// the correct column datatype.
//Column("GateCharge_DRDS-8.5") << Data Type ("Numeric");
//Column("GateCharge_DRDS-8.5") << Modeling Type ("Continuous");

// Set the Modeling Type of some columns
Column("Device") << Modeling Type("Ordinal");
Column("Site") << Modeling Type("Ordinal");
Column("X") << Modeling Type("Ordinal");
Column("Y") << Modeling Type("Ordinal");
Column("Soft Bin") << Modeling Type("Nominal");
Column("Hard Bin") << Modeling Type("Nominal");
Column("Wafer") << Modeling Type("Ordinal");
